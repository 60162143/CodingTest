
# 문제 : https://www.acmicpc.net/problem/29236

# keyPoint
# 1. 문제를 이해하는데만 하루가 걸린 딥빡문제....
# 2. 문제가 요구하는 개념만 바르게 이해하면 너무나도 쉽게 풀수 있었던 문제였던...
# 3. 리프노드의 개수가 가장 높고, 그 리프노드의 깊이가 가장 깊은 경우
 -> 노드 개수의 중앙값만큼은 정점을 일직선으로 쭉 뻗고 나머지 정점을 중앙값의 정점에 리프노드로 붙어 있을때가 가장 많다!!
 
ex) 노드의 개수가 5개인 경우   => 나무의 길이 = 리프노드의 depth의 합

리프 노드의 개수가 1개일 경우의 최대    = >    1 - 2 - 3 - 4 - 5    = > 1 * 4 = 4

리프 노드의 개수가 2개일 경우의 최대    = >    1 - 2 - 3---5        = > 2 * 3 = 6
                                                    └---4
리프 노드의 개수가 2개일 경우의 최대    = >    1 - 2---5        = > 2 * 3 = 6
                                                └---4
                                                └---3
리프 노드의 개수가 1개일 경우의 최대    = >    1 ---5        = > 1 * 4 = 4
                                            └---4
                                            └---3
                                            └---2

따라서 중앙값을 찾으면 그 값만큼의 깊이에 리프노드가 붙어있는 경우가 최대값이다!

# code
n = int(input())
print(((n + 1) // 2) * (n // 2))  # 중앙값 * 중앙값까지 일직선으로 뻗은 노드를 제외한 나머지 리프 노드의 수
